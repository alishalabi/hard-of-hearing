{"version":3,"sources":["request.ts"],"names":["_checkStatus","res","status","Promise","reject","resolve","_tryParseJSON","json","catch","error","_fetchJSON","url","_ref","arguments","length","undefined","headers","method","mode","options","_objectWithoutProperties","fetchHeaders","Content-Type","fetchOptions","credentials","fetch","then","_catchStatusError","responseData","response","parsedError","description","argumentErrors","_parseError"],"mappings":"mhBAOA,IAAMA,EAAe,SAACC,GAClB,OAAIA,EAAIC,QAAU,IAGPC,QAAQC,OAAOH,GAEnBE,QAAQE,QAAQJ,IAGrBK,EAAgB,SAACL,GACnB,IACI,OACIA,EACKM,OAKAC,MAAM,WAAA,OAAML,QAAQC,OAAOH,KAEtC,MAAOQ,GACL,OAAON,QAAQC,OAAOH,KASjBS,EAAa,SACtBC,GAEc,IAAAC,EAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,MADbG,EACaJ,EADbI,QAASC,EACIL,EADJK,OAAQC,EACJN,EADIM,KAASC,yTACbC,CAAAR,GAAA,UAAA,SAAA,SACVS,EAAeL,EAEJ,QAAXC,IACAI,EAAAA,GACIC,eAAgB,oBACbN,IAIX,IAAMO,EAAAA,GACFN,OAAAA,EACAC,KAAAA,EACAF,QAASK,EACTG,YAAsB,SAATN,EAAkB,UAAY,eACxCC,GAGP,OAAOM,MAAMd,EAAKY,GACbG,KAAK1B,GACL0B,KAAKpB,mBAGd,IA6DMqB,EAAoB,SAAC1B,GAAD,OACtB,IAAIE,QAAQ,SAACE,EAASD,GAClBE,EAAcL,GAETyB,KAAK,SAACE,GAAD,OACFxB,GACIyB,SAAU5B,EACV6B,YAxCA,SAACF,GACjB,IAAKA,EAAanB,MAEd,OAAO,KAGX,IAlCwBmB,EAkCpBnB,GACAA,MAAOmB,EAAanB,MACpBsB,YAAaH,EAAA,mBAUjB,OA9CwBA,EAuCDA,GArCnB,cACAA,EAAA,aAAA,kBAqCAnB,EAAAA,KACOA,GACHuB,eAAgBJ,EAAA,aAAA,mBAIjBnB,EAsBsBwB,CAAYL,OAKhCpB,MAAM,WAAA,OACHJ,GACIyB,SAAU5B,mBASf,SAACU,EAAaQ,GAAd,OACXT,EAAWC,EAAKQ,GAASX,MAAMmB","file":"request.min.js","sourcesContent":["import {JSONResponseData, ParsedResponseError} from './types';\nimport 'isomorphic-fetch';\n\n/**\n * Return a promise that is resolved or rejected depending on the response's\n * status code.\n */\nconst _checkStatus = (res: Response): Promise<Response> => {\n    if (res.status >= 400) {\n        // Need to wrap the response in an object so that it matches the same error object\n        // returned by _catchStatusError\n        return Promise.reject(res);\n    }\n    return Promise.resolve(res);\n};\n\nconst _tryParseJSON = (res: Response): Promise<any> => {\n    try {\n        return (\n            res\n                .json()\n\n                // if JSON cannot parse, it'll return a rejected promise instead\n                // of throwing an error, so we catch that rejection so that we can rejected\n                // with the response like everything else expects\n                .catch(() => Promise.reject(res))\n        );\n    } catch (error) {\n        return Promise.reject(res);\n    }\n};\n\n/**\n * Calls fetch on provided url with default options necessary for interacting\n * with our JSON API. Parses the JSON, provides appropriate headers, and asserts\n * a valid status from the server.\n */\nexport const _fetchJSON = (\n    url: string,\n    {headers, method, mode, ...options}: RequestInit = {}\n): Promise<{}> => {\n    let fetchHeaders = headers as HeadersInit;\n\n    if (method !== 'GET') {\n        fetchHeaders = {\n            'Content-Type': 'application/json',\n            ...headers,\n        };\n    }\n\n    const fetchOptions = {\n        method,\n        mode,\n        headers: fetchHeaders,\n        credentials: mode === 'cors' ? 'include' : 'same-origin',\n        ...options,\n    } as RequestInit;\n\n    return fetch(url, fetchOptions)\n        .then(_checkStatus)\n        .then(_tryParseJSON);\n};\n\nconst _hasArgumentsError = (responseData: JSONResponseData): boolean =>\n    !!(\n        responseData['error_detail'] &&\n        responseData['error_detail']['ARGUMENTS_ERROR']\n    );\n\n/**\n * Parse v3 errors into an array of objects representing the errors returned by\n * the API. The format of the parsed errors looks like:\n *\n *  {\n *      status_code: 400,\n *      error: 'ERROR_CODE',\n *      description: 'Description of the error\n *  }\n *\n * An ARGUMENTS_ERROR looks like:\n *\n *  {\n *      error: 'ARGUMENTS_ERROR',\n *      description: 'Some of the fields were invalid or something',\n *      argumentErrors: {\n *          attr1: ['INVALID'],\n *          attr2: ['This field is required']\n *      }\n *  }\n *\n */\nconst _parseError = (responseData: JSONResponseData): ParsedResponseError => {\n    if (!responseData.error) {\n        // Weird error format, return null\n        return null;\n    }\n\n    let error = {\n        error: responseData.error,\n        description: responseData['error_description'],\n    } as ParsedResponseError;\n\n    if (_hasArgumentsError(responseData)) {\n        error = {\n            ...error,\n            argumentErrors: responseData['error_detail']['ARGUMENTS_ERROR'],\n        };\n    }\n\n    return error;\n};\n\n/**\n * Designed to work with `_checkStatus`, or any function that\n * raises an error on an invalid status. The error raised should have a `response`\n * property with the original response object.\n *\n * Example usage:\n *\n * _fetchJSON('/api/v3/test/path', {'body': someData})\n *     .catch(_catchStatusError)\n *     .then(doSomethingOnSuccess)\n *     .catch(({response, parsedError}) => doSomethingOnError());\n */\nconst _catchStatusError = (res: Response): Promise<any> =>\n    new Promise((resolve, reject) => {\n        _tryParseJSON(res)\n            // handled error, so reject with parsed error data along with response\n            .then((responseData: JSONResponseData) =>\n                reject({\n                    response: res,\n                    parsedError: _parseError(responseData),\n                })\n            )\n\n            // Unhandled error\n            .catch(() =>\n                reject({\n                    response: res,\n                })\n            );\n    });\n\n/**\n * Low-level method that makes fetch requests, returning the response formatted as JSON.\n * It parses errors from API v3 and throws exceptions with those errors\n */\nexport default (url: string, options?: RequestInit): Promise<{}> =>\n    _fetchJSON(url, options).catch(_catchStatusError);\n"]}