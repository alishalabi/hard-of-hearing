{"version":3,"sources":["request.ts"],"names":["_checkStatus","res","status","Promise","reject","resolve","_tryParseJSON","json","catch","error","_fetchJSON","url","headers","method","mode","options","fetchHeaders","fetchOptions","credentials","fetch","then","_hasArgumentsError","responseData","_parseError","description","argumentErrors","_catchStatusError","response","parsedError"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;AAIA,MAAMA,eAAe,SAAfA,YAAe,CAACC,GAAD,EAAsC;AACvD,QAAIA,IAAIC,MAAJ,IAAc,GAAlB,EAAuB;AACnB;AACA;AACA,aAAOC,QAAQC,MAAR,CAAeH,GAAf,CAAP;AACH;;AACD,WAAOE,QAAQE,OAAR,CAAgBJ,GAAhB,CAAP;AACH,GAPD;;AASA,MAAMK,gBAAgB,SAAhBA,aAAgB,CAACL,GAAD,EAAiC;AACnD,QAAI;AACA,aACIA,IACKM,IADL,GAGI;AACA;AACA;AALJ,OAMKC,KANL,CAMW;AAAA,eAAML,QAAQC,MAAR,CAAeH,GAAf,CAAN;AAAA,OANX,CADJ;AASH,KAVD,CAUE,OAAOQ,KAAP,EAAc;AACZ,aAAON,QAAQC,MAAR,CAAeH,GAAf,CAAP;AACH;AACJ,GAdD;AAgBA;;;;;;;AAKO,MAAMS,aAAa,SAAbA,UAAa,CACtBC,GADsB,EAGR;AAAA,mFADqC,EACrC;;AAAA,QADbC,OACa,QADbA,OACa;AAAA,QADJC,MACI,QADJA,MACI;AAAA,QADIC,IACJ,QADIA,IACJ;AAAA,QADaC,OACb;;AACd,QAAIC,eAAeJ,OAAnB;;AAEA,QAAIC,WAAW,KAAf,EAAsB;AAClBG;AACI,wBAAgB;AADpB,SAEOJ,OAFP;AAIH;;AAED,QAAMK;AACFJ,oBADE;AAEFC,gBAFE;AAGFF,eAASI,YAHP;AAIFE,mBAAaJ,SAAS,MAAT,GAAkB,SAAlB,GAA8B;AAJzC,OAKCC,OALD,CAAN;;AAQA,WAAOI,MAAMR,GAAN,EAAWM,YAAX,EACFG,IADE,CACGpB,YADH,EAEFoB,IAFE,CAEGd,aAFH,CAAP;AAGH,GAxBM;;;;AA0BP,MAAMe,qBAAqB,SAArBA,kBAAqB,CAACC,YAAD;AAAA,WACvB,CAAC,EACGA,aAAa,cAAb,KACAA,aAAa,cAAb,EAA6B,iBAA7B,CAFH,CADsB;AAAA,GAA3B;AAMA;;;;;;;;;;;;;;;;;;;;;;;;AAsBA,MAAMC,cAAc,SAAdA,WAAc,CAACD,YAAD,EAAyD;AACzE,QAAI,CAACA,aAAab,KAAlB,EAAyB;AACrB;AACA,aAAO,IAAP;AACH;;AAED,QAAIA,QAAQ;AACRA,aAAOa,aAAab,KADZ;AAERe,mBAAaF,aAAa,mBAAb;AAFL,KAAZ;;AAKA,QAAID,mBAAmBC,YAAnB,CAAJ,EAAsC;AAClCb,2BACOA,KADP;AAEIgB,wBAAgBH,aAAa,cAAb,EAA6B,iBAA7B;AAFpB;AAIH;;AAED,WAAOb,KAAP;AACH,GAnBD;AAqBA;;;;;;;;;;;;;;AAYA,MAAMiB,oBAAoB,SAApBA,iBAAoB,CAACzB,GAAD;AAAA,WACtB,IAAIE,OAAJ,CAAY,UAACE,OAAD,EAAUD,MAAV,EAAqB;AAC7BE,oBAAcL,GAAd,EACI;AADJ,OAEKmB,IAFL,CAEU,UAACE,YAAD;AAAA,eACFlB,OAAO;AACHuB,oBAAU1B,GADP;AAEH2B,uBAAaL,YAAYD,YAAZ;AAFV,SAAP,CADE;AAAA,OAFV,EASI;AATJ,OAUKd,KAVL,CAUW;AAAA,eACHJ,OAAO;AACHuB,oBAAU1B;AADP,SAAP,CADG;AAAA,OAVX;AAeH,KAhBD,CADsB;AAAA,GAA1B;AAmBA;;;;;;iBAIe,kBAACU,GAAD,EAAcI,OAAd;AAAA,WACXL,WAAWC,GAAX,EAAgBI,OAAhB,EAAyBP,KAAzB,CAA+BkB,iBAA/B,CADW;AAAA,G","file":"request.js","sourcesContent":["import {JSONResponseData, ParsedResponseError} from './types';\nimport 'isomorphic-fetch';\n\n/**\n * Return a promise that is resolved or rejected depending on the response's\n * status code.\n */\nconst _checkStatus = (res: Response): Promise<Response> => {\n    if (res.status >= 400) {\n        // Need to wrap the response in an object so that it matches the same error object\n        // returned by _catchStatusError\n        return Promise.reject(res);\n    }\n    return Promise.resolve(res);\n};\n\nconst _tryParseJSON = (res: Response): Promise<any> => {\n    try {\n        return (\n            res\n                .json()\n\n                // if JSON cannot parse, it'll return a rejected promise instead\n                // of throwing an error, so we catch that rejection so that we can rejected\n                // with the response like everything else expects\n                .catch(() => Promise.reject(res))\n        );\n    } catch (error) {\n        return Promise.reject(res);\n    }\n};\n\n/**\n * Calls fetch on provided url with default options necessary for interacting\n * with our JSON API. Parses the JSON, provides appropriate headers, and asserts\n * a valid status from the server.\n */\nexport const _fetchJSON = (\n    url: string,\n    {headers, method, mode, ...options}: RequestInit = {}\n): Promise<{}> => {\n    let fetchHeaders = headers as HeadersInit;\n\n    if (method !== 'GET') {\n        fetchHeaders = {\n            'Content-Type': 'application/json',\n            ...headers,\n        };\n    }\n\n    const fetchOptions = {\n        method,\n        mode,\n        headers: fetchHeaders,\n        credentials: mode === 'cors' ? 'include' : 'same-origin',\n        ...options,\n    } as RequestInit;\n\n    return fetch(url, fetchOptions)\n        .then(_checkStatus)\n        .then(_tryParseJSON);\n};\n\nconst _hasArgumentsError = (responseData: JSONResponseData): boolean =>\n    !!(\n        responseData['error_detail'] &&\n        responseData['error_detail']['ARGUMENTS_ERROR']\n    );\n\n/**\n * Parse v3 errors into an array of objects representing the errors returned by\n * the API. The format of the parsed errors looks like:\n *\n *  {\n *      status_code: 400,\n *      error: 'ERROR_CODE',\n *      description: 'Description of the error\n *  }\n *\n * An ARGUMENTS_ERROR looks like:\n *\n *  {\n *      error: 'ARGUMENTS_ERROR',\n *      description: 'Some of the fields were invalid or something',\n *      argumentErrors: {\n *          attr1: ['INVALID'],\n *          attr2: ['This field is required']\n *      }\n *  }\n *\n */\nconst _parseError = (responseData: JSONResponseData): ParsedResponseError => {\n    if (!responseData.error) {\n        // Weird error format, return null\n        return null;\n    }\n\n    let error = {\n        error: responseData.error,\n        description: responseData['error_description'],\n    } as ParsedResponseError;\n\n    if (_hasArgumentsError(responseData)) {\n        error = {\n            ...error,\n            argumentErrors: responseData['error_detail']['ARGUMENTS_ERROR'],\n        };\n    }\n\n    return error;\n};\n\n/**\n * Designed to work with `_checkStatus`, or any function that\n * raises an error on an invalid status. The error raised should have a `response`\n * property with the original response object.\n *\n * Example usage:\n *\n * _fetchJSON('/api/v3/test/path', {'body': someData})\n *     .catch(_catchStatusError)\n *     .then(doSomethingOnSuccess)\n *     .catch(({response, parsedError}) => doSomethingOnError());\n */\nconst _catchStatusError = (res: Response): Promise<any> =>\n    new Promise((resolve, reject) => {\n        _tryParseJSON(res)\n            // handled error, so reject with parsed error data along with response\n            .then((responseData: JSONResponseData) =>\n                reject({\n                    response: res,\n                    parsedError: _parseError(responseData),\n                })\n            )\n\n            // Unhandled error\n            .catch(() =>\n                reject({\n                    response: res,\n                })\n            );\n    });\n\n/**\n * Low-level method that makes fetch requests, returning the response formatted as JSON.\n * It parses errors from API v3 and throws exceptions with those errors\n */\nexport default (url: string, options?: RequestInit): Promise<{}> =>\n    _fetchJSON(url, options).catch(_catchStatusError);\n"]}